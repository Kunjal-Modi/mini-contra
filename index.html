<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Contra</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html, body {
      margin:0; padding:0; overflow:hidden;
      background: #111;
      font-family: 'Press Start 2P', cursive;
      user-select:none;
      color:#fff;
    }
    #gameCanvas {
      background: #111;
      display: block;
      margin: 0 auto;
      border: 4px solid #0f0;
      image-rendering: pixelated;
      width: 800px;
      height: 450px;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: #0f0;
      text-shadow: 0 0 6px #0f0;
      z-index: 10;
      user-select:none;
      white-space: nowrap;
    }
    #retryBtn {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #0f0;
      border: none;
      border-radius: 12px;
      padding: 15px 40px;
      font-size: 20px;
      font-weight: 700;
      color: #000;
      cursor: pointer;
      box-shadow: 0 0 15px #0f0;
      display: none;
      user-select:none;
      font-family: 'Press Start 2P', cursive;
    }
    #retryBtn:hover {
      background: #0a0;
    }
  </style>
</head>
<body>
  <div id="ui">Score: 0 | High Score: 0 | Ammo: 50 | Health: 3</div>
  <button id="retryBtn">RETRY</button>
  <canvas id="gameCanvas" width="800" height="450"></canvas>
  <script>
(() => {
  // Setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const ui = document.getElementById('ui');
  const retryBtn = document.getElementById('retryBtn');

  // Retro palette colors
  const COLORS = {
    bgDark: '#B2FF66',
    bgLight: '#121519',
    platform: '#2df442',
    player: '#9933ff',
    playerShot: '#f8ff1c',
    enemy: '#ff3333',
    enemyShot: '#ffcc00',
    powerup: '#3dffd6',
    boss: '#ff66cc',
  };

  // Fonts & settings
  const font = "'Press Start 2P', cursive";

  // Game state
  let gameSpeed = 2;
  let gravity = 0.6;
  let score = 0;
  let highScore = localStorage.getItem('miniContraHighScore') || 0;
  let ammoMax = 50;
  let ammo = ammoMax;
  let playerMaxHealth = 3;
  let playerHealth = playerMaxHealth;
  let gameOver = false;
  let keys = {};

  // Level & world
  let scrollX = 0;
  let platforms = [];
  let enemies = [];
  let enemyShots = [];
  let playerShots = [];
  let powerUps = [];
  let boss = null;
  let bossFight = false;

  // Player
  const player = {
    x: 100,
    y: height - 90,
    w: 28,
    h: 36,
    vy: 0,
    onGround: false,
    facing: 1,
    shootCooldown: 0,
  };

  // Sounds using WebAudio - simple retro beeps
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();

  function playBeep(freq, duration=0.1, type='square', volume=0.15){
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(volume, audioCtx.currentTime);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  // Controls
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(gameOver && e.code === 'Enter') restartGame();
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
  });

  // Touch controls (tap to jump/shoot)
  window.addEventListener('touchstart', e => {
    e.preventDefault();
    if(gameOver) restartGame();
    else {
      if(player.onGround) jump();
      else shoot();
    }
  }, {passive:false});

  // Create platforms dynamically
  function generatePlatforms(){
    platforms = [];
    let x = 0;
    while(x < 3000){
      const w = 80 + Math.random()*120;
      const h = 15;
      let y = height - 50 - Math.random()*150;
      if(y > height - 90) y = height - 90;
      platforms.push({x, y, w, h});
      x += w + 60 + Math.random()*40;
    }
  }

  // Create enemies dynamically based on platforms
  function generateEnemies(){
    enemies = [];
    platforms.forEach(p => {
      // 40% chance to spawn enemy on platform
      if(Math.random() < 0.4){
        enemies.push({
          x: p.x + p.w/2 - 14,
          y: p.y - 36,
          w: 28,
          h: 36,
          vy: 0,
          onGround: false,
          dir: Math.random() < 0.5 ? -1 : 1,
          shootTimer: 0,
          health: 1,
        });
      }
    });
  }

  // Powerups
  function createPowerUp(x, y){
    powerUps.push({
      x, y, w:20, h:20,
      type: Math.random() < 0.5 ? 'ammo' : 'health',
      vy: 0,
      onGround: false,
    });
  }

  // Boss creation
  function createBoss(){
    bossFight = true;
    boss = {
      x: scrollX + width + 100,
      y: height - 140,
      w: 64,
      h: 96,
      health: 10,
      dir: -1,
      shootTimer: 0,
      vy: 0,
      onGround: false,
    };
  }

  // Jump player
  function jump(){
    if(player.onGround){
      player.vy = -13;
      player.onGround = false;
      playBeep(880, 0.12, 'square', 0.2);
    }
  }

  // Shoot player shot
  function shoot(){
    if(player.shootCooldown <= 0 && ammo > 0){
      playerShots.push({
        x: player.x + (player.facing === 1 ? player.w : 0) + (player.facing === 1 ? 4 : -8),
        y: player.y + player.h / 2 - 4,
        w: 8,
        h: 4,
        vx: 12 * player.facing,
      });
      ammo--;
      player.shootCooldown = 15;
      playBeep(1400, 0.07, 'square', 0.18);
    }
  }

  // Enemy shoot
  function enemyShoot(enemy){
    enemyShots.push({
      x: enemy.x + enemy.w / 2 - 4,
      y: enemy.y + enemy.h / 2,
      w: 8,
      h: 4,
      vx: -8,
    });
    playBeep(600, 0.08, 'triangle', 0.15);
  }

  // Collision helpers
  function rectIntersect(a, b){
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Update entities physics
  function applyGravity(entity){
    entity.vy += gravity;
    entity.y += entity.vy;
    // Check collision with platforms or floor
    let onGround = false;
    for(let p of platforms){
      if(entity.x + entity.w > p.x && entity.x < p.x + p.w){
        if(entity.y + entity.h > p.y && entity.y + entity.h < p.y + p.h + 10){
          entity.y = p.y - entity.h;
          entity.vy = 0;
          onGround = true;
          break;
        }
      }
    }
    if(entity.y + entity.h > height - 40){
      entity.y = height - 40 - entity.h;
      entity.vy = 0;
      onGround = true;
    }
    return onGround;
  }

  // Update player
  function updatePlayer(){
    if(keys['ArrowLeft']){
      player.x -= 4;
      player.facing = -1;
    }
    if(keys['ArrowRight']){
      player.x += 4;
      player.facing = 1;
    }
    // Boundaries
    if(player.x < scrollX) player.x = scrollX;
    if(player.x + player.w > scrollX + width) player.x = scrollX + width - player.w;

    // Jump
    if(keys['ArrowUp'] || keys['Space']) jump();

    player.onGround = applyGravity(player);

    // Shooting
    if(keys['KeyZ']) shoot();

    // Cooldowns
    if(player.shootCooldown > 0) player.shootCooldown--;

    // Scroll world if player moves past center right
    const centerX = scrollX + width / 2;
    if(player.x > centerX) scrollX = player.x - width / 2;
  }

  // Update platforms (they don't move)

  // Update enemies
  function updateEnemies(){
    enemies.forEach(e => {
      e.x += e.dir * 1.2 * gameSpeed / 2;
      e.onGround = applyGravity(e);

      // Change direction at platform edges
      let onPlatform = false;
      for(let p of platforms){
        if(e.x + e.w > p.x && e.x < p.x + p.w && Math.abs(e.y + e.h - p.y) < 3){
          onPlatform = true;
          // Edge detection
          if(e.x <= p.x || e.x + e.w >= p.x + p.w){
            e.dir *= -1;
          }
        }
      }
      if(!onPlatform) e.dir *= -1;

      // Enemy shooting
      e.shootTimer--;
      if(e.shootTimer <= 0){
        enemyShoot(e);
        e.shootTimer = 120 + Math.floor(Math.random() * 120);
      }
    });
  }

  // Update boss
  function updateBoss(){
    if(!boss) return;
    boss.x += boss.dir * 1.5;
    boss.onGround = applyGravity(boss);

    // Change direction at screen edges
    if(boss.x < scrollX + 400) boss.dir = 1;
    if(boss.x + boss.w > scrollX + width - 100) boss.dir = -1;

    boss.shootTimer--;
    if(boss.shootTimer <= 0){
      enemyShoot(boss);
      boss.shootTimer = 60;
    }
  }

  // Update shots
  function updateShots(){
    // Player shots
    playerShots.forEach((s, i) => {
      s.x += s.vx;
      // Remove if out of screen
      if(s.x < scrollX || s.x > scrollX + width) playerShots.splice(i, 1);
    });

    // Enemy shots
    enemyShots.forEach((s, i) => {
      s.x += s.vx;
      if(s.x < scrollX || s.x > scrollX + width) enemyShots.splice(i, 1);
    });
  }

  // Update powerups
  function updatePowerUps(){
    powerUps.forEach((p, i) => {
      p.onGround = applyGravity(p);
      // Pickup if player touches
      if(rectIntersect(player, p)){
        if(p.type === 'ammo'){
          ammo = Math.min(ammo + 5, ammoMax);
          playBeep(1200, 0.15, 'square', 0.2);
        } else if(p.type === 'health'){
          playerHealth = Math.min(playerHealth + 1, playerMaxHealth);
          playBeep(1000, 0.2, 'triangle', 0.25);
        }
        powerUps.splice(i, 1);
      }
    });
  }

  // Collision handling
  function handleCollisions(){
    // Player shots vs enemies
    playerShots.forEach((shot, si) => {
      enemies.forEach((e, ei) => {
        if(rectIntersect(shot, e)){
          e.health--;
          playerShots.splice(si,1);
          if(e.health <= 0){
            score += 10;
            // Chance to drop powerup
            if(Math.random() < 0.3){
              createPowerUp(e.x, e.y);
            }
            enemies.splice(ei, 1);
            playBeep(1600, 0.1, 'square', 0.3);
          } else {
            playBeep(1200, 0.07, 'square', 0.2);
          }
        }
      });
      // Player shots vs boss
      if(boss && rectIntersect(shot, boss)){
        boss.health--;
        playerShots.splice(si, 1);
        playBeep(1000, 0.15, 'square', 0.3);
        if(boss.health <= 0){
          score += 100;
          playBeep(2000, 0.5, 'triangle', 0.4);
          boss = null;
          bossFight = false;
          // Reset level / speed boost
          gameSpeed += 0.5;
          // Regenerate level & enemies
          generatePlatforms();
          generateEnemies();
        }
      }
    });

    // Enemy shots vs player
    enemyShots.forEach((shot, si) => {
      if(rectIntersect(shot, player)){
        enemyShots.splice(si, 1);
        playerHealth--;
        playBeep(300, 0.3, 'sawtooth', 0.3);
        if(playerHealth <= 0) endGame();
      }
    });

    // Enemies vs player collision (touch)
    enemies.forEach(e => {
      if(rectIntersect(e, player)){
        playerHealth--;
        playBeep(300, 0.3, 'sawtooth', 0.3);
        enemies.splice(enemies.indexOf(e),1);
        if(playerHealth <= 0) endGame();
      }
    });

    // Boss vs player collision
    if(boss && rectIntersect(boss, player)){
      playerHealth--;
      playBeep(300, 0.3, 'sawtooth', 0.3);
      if(playerHealth <= 0) endGame();
    }
  }

  // Draw helpers

  function drawText(text, x, y, color='#0f0', shadow=true){
    ctx.font = '16px ' + font;
    ctx.fillStyle = color;
    if(shadow){
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 5;
    }
    ctx.fillText(text, x, y);
    ctx.shadowBlur = 0;
  }

  // Draw player (retro pixel style)
  function drawPlayer(){
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(player.x - scrollX, player.y, player.w, player.h);
    // Face detail (simple eyes)
    ctx.fillStyle = '#000';
    ctx.fillRect(player.x - scrollX + 6, player.y + 8, 5, 5);
    ctx.fillRect(player.x - scrollX + 16, player.y + 8, 5, 5);
  }

  // Draw enemy
  function drawEnemy(e){
    ctx.fillStyle = COLORS.enemy;
    ctx.fillRect(e.x - scrollX, e.y, e.w, e.h);
    // eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(e.x - scrollX + 6, e.y + 10, 5, 5);
    ctx.fillRect(e.x - scrollX + 16, e.y + 10, 5, 5);
  }

  // Draw boss
  function drawBoss(){
    if(!boss) return;
    ctx.fillStyle = COLORS.boss;
    ctx.fillRect(boss.x - scrollX, boss.y, boss.w, boss.h);
    // boss eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(boss.x - scrollX + 14, boss.y + 20, 8, 8);
    ctx.fillRect(boss.x - scrollX + 40, boss.y + 20, 8, 8);
  }

  // Draw shots
  function drawShots(){
    ctx.fillStyle = COLORS.playerShot;
    playerShots.forEach(s => {
      ctx.fillRect(s.x - scrollX, s.y, s.w, s.h);
    });
    ctx.fillStyle = COLORS.enemyShot;
    enemyShots.forEach(s => {
      ctx.fillRect(s.x - scrollX, s.y, s.w, s.h);
    });
  }

  // Draw platforms
  function drawPlatforms(){
    ctx.fillStyle = COLORS.platform;
    platforms.forEach(p => {
      ctx.fillRect(p.x - scrollX, p.y, p.w, p.h);
    });
  }

  // Draw powerups
  function drawPowerUps(){
    powerUps.forEach(p => {
      ctx.fillStyle = p.type === 'ammo' ? COLORS.powerup : '#f55';
      ctx.fillRect(p.x - scrollX, p.y, p.w, p.h);
      // simple blinking effect
      if(Math.floor(Date.now() / 300) % 2 === 0){
        ctx.fillStyle = '#fff';
        ctx.fillRect(p.x - scrollX + 5, p.y + 5, 10, 10);
      }
    });
  }

  // Parallax background layers
  const bgLayers = [
    {color:'#0f120f', speed: 0.2, shapes:[]},
    {color:'#1a2d1a', speed: 0.4, shapes:[]},
    {color:'#225522', speed: 0.8, shapes:[]},
  ];
  
  // Draw parallax background
  function drawBackground(){
    bgLayers.forEach(layer => {
      ctx.fillStyle = layer.color;
      ctx.fillRect(0,0,width,height);
      layer.shapes.forEach(s => {
        let drawX = (s.x - scrollX * layer.speed) % (200 * 40);
        if(drawX < -s.w) drawX += 200 * 40;
        ctx.fillStyle = '#145214';
        ctx.beginPath();
        ctx.moveTo(drawX, height - 40 - s.offsetY);
        ctx.lineTo(drawX + s.w/2, height - 40 - s.h - s.offsetY);
        ctx.lineTo(drawX + s.w, height - 40 - s.offsetY);
        ctx.closePath();
        ctx.fill();
      });
    });
  }

  // Game loop
  function update(){
    if(gameOver) return;

    // Increase difficulty gradually
    if(score > 0 && score % 200 === 0) {
      gameSpeed += 0.001;
    }

    updatePlayer();
    updateEnemies();
    updateBoss();
    updateShots();
    updatePowerUps();
    handleCollisions();

    // Scroll world forward automatically
    scrollX += gameSpeed * 0.8;

    // Spawn boss fight every ~1500 scroll units
    if(!bossFight && scrollX > 1500 && enemies.length === 0){
      createBoss();
    }

    // Update UI
    ui.textContent = `Score: ${score} | High Score: ${highScore} | Ammo: ${ammo} | Health: ${playerHealth}`;

    // Update score as player passes platforms
    platforms.forEach(p => {
      if(p.x + p.w < scrollX && !p.scored){
        score += 1;
        p.scored = true;
        if(score > highScore){
          highScore = score;
          localStorage.setItem('miniContraHighScore', highScore);
        }
        playBeep(1000 + score * 2, 0.05, 'square', 0.15);
      }
    });
  }

  function draw(){
    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw backgrounds
    drawBackground();

    // Draw platforms
    drawPlatforms();

    // Draw powerups
    drawPowerUps();

    // Draw player
    drawPlayer();

    // Draw enemies
    enemies.forEach(drawEnemy);

    // Draw boss
    drawBoss();

    // Draw shots
    drawShots();
  }

  function loop(){
    update();
    draw();
    if(!gameOver) requestAnimationFrame(loop);
  }

  // End game
  function endGame(){
    gameOver = true;
    retryBtn.style.display = 'block';
    playBeep(200, 0.6, 'sawtooth', 0.4);
  }

  // Restart game
  function restartGame(){
    retryBtn.style.display = 'none';
    scrollX = 0;
    score = 0;
    ammo = ammoMax;
    playerHealth = playerMaxHealth;
    player.x = 100;
    player.y = height - 90;
    player.vy = 0;
    gameSpeed = 2;
    gameOver = false;
    boss = null;
    bossFight = false;
    platforms.forEach(p => p.scored = false);
    generatePlatforms();
    generateEnemies();
    generateBgShapes();
    playerShots.length = 0;
    enemyShots.length = 0;
    powerUps.length = 0;
    loop();
  }

  retryBtn.addEventListener('click', restartGame);

  // Initialize
  generatePlatforms();
  generateEnemies();
  generateBgShapes();
  loop();

})();
  </script>
</body>
</html>
